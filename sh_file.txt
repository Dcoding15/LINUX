DASH(1)                                                                                   BSD General Commands Manual                                                                                  DASH(1)

NAME
     dash — command interpreter (shell)

SYNOPSIS
     dash [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o option_name] [+o option_name] [command_file [argument ...]]
     dash -c [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o option_name] [+o option_name] command_string [command_name [argument ...]]
     dash -s [-aCefnuvxIimqVEbp] [+aCefnuvxIimqVEbp] [-o option_name] [+o option_name] [argument ...]

   Invocation
     If no args are present and if the standard input of the shell is connected to a terminal (or if the -i flag is set), and the -c option is not present, the shell is considered an interactive shell.  An
     interactive shell generally prompts before each command and handles programming and command errors differently (as described below).  When first starting, the shell inspects argument 0, and if it be‐
     gins with a dash ‘-’, the shell is also considered a login shell.  This is normally done automatically by the system when the user first logs in.  A login shell first reads commands from the files
     /etc/profile and .profile if they exist.  If the environment variable ENV is set on entry to an interactive shell, or is set in the .profile of a login shell, the shell next reads commands from the
     file named in ENV.  Therefore, a user should place commands that are to be executed only at login time in the .profile file, and commands that are executed for every interactive shell inside the ENV
     file.  To set the ENV variable to some file, place the following line in your .profile of your home directory

           ENV=$HOME/.shinit; export ENV

     substituting for “.shinit” any filename you wish.

     If command line arguments besides the options have been specified, then the shell treats the first argument as the name of a file from which to read commands (a shell script), and the remaining argu‐
     ments are set as the positional parameters of the shell ($1, $2, etc).  Otherwise, the shell reads commands from its standard input.

   Argument List Processing
     All of the single letter options that have a corresponding name can be used as an argument to the -o option.  The set -o name is provided next to the single letter option in the description below.
     Specifying a dash “-” turns the option on, while using a plus “+” disables the option.  The following options can be set from the command line or with the set builtin (described later).

           -a allexport     Export all variables assigned to.

           -c               Read commands from the command_string operand instead of from the standard input.  Special parameter 0 will be set from the command_name operand and the positional parameters
                            ($1, $2, etc.)  set from the remaining argument operands.

           -C noclobber     Don't overwrite existing files with “>”.

           -e errexit       If not interactive, exit immediately if any untested command fails.  The exit status of a command is considered to be explicitly tested if the command is used to control an if,
                            elif, while, or until; or if the command is the left hand operand of an “&&” or “||” operator.

           -f noglob        Disable pathname expansion.

           -n noexec        If not interactive, read commands but do not execute them.  This is useful for checking the syntax of shell scripts.

           -u nounset       Write a message to standard error when attempting to expand a variable that is not set, and if the shell is not interactive, exit immediately.

           -v verbose       The shell writes its input to standard error as it is read.  Useful for debugging.

           -x xtrace        Write each command to standard error (preceded by a ‘+ ’) before it is executed.  Useful for debugging.

           -I ignoreeof     Ignore EOF's from input when interactive.

           -i interactive   Force the shell to behave interactively.

           -l               Make dash act as if it had been invoked as a login shell.

           -m monitor       Turn on job control (set automatically when interactive).

           -s stdin         Read commands from standard input (set automatically if no file arguments are present).  This option has no effect when set after the shell has already started running (i.e. with
                            set).

           -V vi            Enable the built-in vi(1) command line editor (disables -E if it has been set).

           -E emacs         Enable the built-in emacs(1) command line editor (disables -V if it has been set).

           -b notify        Enable asynchronous notification of background job completion.  (UNIMPLEMENTED for 4.4alpha)

           -p priviliged    Do not attempt to reset effective uid if it does not match uid. This is not set by default to help avoid incorrect usage by setuid root programs via system(3) or popen(3).

   Lexical Structure
     The shell reads input in terms of lines from a file and breaks it up into words at whitespace (blanks and tabs).

     There are two types of operators: control operators and redirection operators (their meaning is discussed later).  Following is a list of operators:

           Control operators:
                 & && ( ) ; ;; | || <newline>

           Redirection operators:
                 < > >| << >> <& >& <<- <>

   Quoting
     Quoting is used to remove the special meaning of certain characters or words to the shell, such as operators, whitespace, or keywords.  There are three types of quoting: matched single quotes, matched
     double quotes, and backslash.

   Backslash
     A backslash preserves the literal meaning of the following character, with the exception of ⟨newline⟩.  A backslash preceding a ⟨newline⟩ is treated as a line continuation.

   Single Quotes
     Enclosing characters in single quotes preserves the literal meaning of all the characters (except single quotes, making it impossible to put single-quotes in a single-quoted string).

   Double Quotes
     Enclosing characters within double quotes preserves the literal meaning of all characters except dollarsign ($), backquote (`), and backslash (\).  The backslash inside double quotes is historically
     weird, and serves to quote only the following characters:
           $ ` " \ <newline>.
     Otherwise it remains literal.

   Reserved Words
     Reserved words are words that have special meaning to the shell and are recognized at the beginning of a line and after a control operator.  The following are reserved words:

           !       elif    fi      while   case
           else    for     then    {       }
           do      done    until   if      esac

     Their meaning is discussed later.

   Aliases
     An alias is a name and corresponding value set using the alias(1) builtin command.  Whenever a reserved word may occur (see above), and after checking for reserved words, the shell checks the word to
     see if it matches an alias.  If it does, it replaces it in the input stream with its value.  For example, if there is an alias called “lf” with the value “ls -F”, then the input:

           lf foobar ⟨return⟩

     would become

           ls -F foobar ⟨return⟩

     Aliases provide a convenient way for naive users to create shorthands for commands without having to learn how to create functions with arguments.  They can also be used to create lexically obscure
     code.  This use is discouraged.

   Commands
     The shell interprets the words it reads according to a language, the specification of which is outside the scope of this man page (refer to the BNF in the POSIX 1003.2 document).  Essentially though, a
     line is read and if the first word of the line (or after a control operator) is not a reserved word, then the shell has recognized a simple command.  Otherwise, a complex command or some other special
     construct may have been recognized.

   Simple Commands
     If a simple command has been recognized, the shell performs the following actions:

           1.   Leading words of the form “name=value” are stripped off and assigned to the environment of the simple command.  Redirection operators and their arguments (as described below) are stripped
                off and saved for processing.

           2.   The remaining words are expanded as described in the section called “Expansions”, and the first remaining word is considered the command name and the command is located.  The remaining words
                are considered the arguments of the command.  If no command name resulted, then the “name=value” variable assignments recognized in item 1 affect the current shell.

           3.   Redirections are performed as described in the next section.

   Redirections
     Redirections are used to change where a command reads its input or sends its output.  In general, redirections open, close, or duplicate an existing reference to a file.  The overall format used for
     redirection is:

           [n] redir-op file

     where redir-op is one of the redirection operators mentioned previously.  Following is a list of the possible redirections.  The [n] is an optional number between 0 and 9, as in ‘3’ (not ‘[3]’), that
     refers to a file descriptor.

           [n]> file   Redirect standard output (or n) to file.

           [n]>| file  Same, but override the -C option.

           [n]>> file  Append standard output (or n) to file.

           [n]< file   Redirect standard input (or n) from file.

           [n1]<&n2    Copy file descriptor n2 as stdout (or fd n1).  fd n2.

           [n]<&-      Close standard input (or n).

           [n1]>&n2    Copy file descriptor n2 as stdin (or fd n1).  fd n2.

           [n]>&-      Close standard output (or n).

           [n]<> file  Open file for reading and writing on standard input (or n).

     The following redirection is often called a “here-document”.

           [n]<< delimiter
                 here-doc-text ...
           delimiter

     All the text on successive lines up to the delimiter is saved away and made available to the command on standard input, or file descriptor n if it is specified.  If the delimiter as specified on the
     initial line is quoted, then the here-doc-text is treated literally, otherwise the text is subjected to parameter expansion, command substitution, and arithmetic expansion (as described in the section
     on “Expansions”).  If the operator is “<<-” instead of “<<”, then leading tabs in the here-doc-text are stripped.

   Search and Execution
     There are three types of commands: shell functions, builtin commands, and normal programs – and the command is searched for (by name) in that order.  They each are executed in a different way.

     When a shell function is executed, all of the shell positional parameters (except $0, which remains unchanged) are set to the arguments of the shell function.  The variables which are explicitly placed
     in the environment of the command (by placing assignments to them before the function name) are made local to the function and are set to the values given.  Then the command given in the function defi‐
     nition is executed.  The positional parameters are restored to their original values when the command completes.  This all occurs within the current shell.

     Shell builtins are executed internally to the shell, without spawning a new process.

     Otherwise, if the command name doesn't match a function or builtin, the command is searched for as a normal program in the file system (as described in the next section).  When a normal program is exe‐
     cuted, the shell runs the program, passing the arguments and the environment to the program.  If the program is not a normal executable file (i.e., if it does not begin with the "magic number" whose
     ASCII representation is "#!", so execve(2) returns ENOEXEC then) the shell will interpret the program in a subshell.  The child shell will reinitialize itself in this case, so that the effect will be
     as if a new shell had been invoked to handle the ad-hoc shell script, except that the location of hashed commands located in the parent shell will be remembered by the child.

     Note that previous versions of this document and the source code itself misleadingly and sporadically refer to a shell script without a magic number as a "shell procedure".

   Path Search
     When locating a command, the shell first looks to see if it has a shell function by that name.  Then it looks for a builtin command by that name.  If a builtin command is not found, one of two things
     happen:

     1.   Command names containing a slash are simply executed without performing any searches.

     2.   The shell searches each entry in PATH in turn for the command.  The value of the PATH variable should be a series of entries separated by colons.  Each entry consists of a directory name.  The
          current directory may be indicated implicitly by an empty directory name, or explicitly by a single period.

   Command Exit Status
     Each command has an exit status that can influence the behaviour of other shell commands.  The paradigm is that a command exits with zero for normal or success, and non-zero for failure, error, or a
     false indication.  The man page for each command should indicate the various exit codes and what they mean.  Additionally, the builtin commands return exit codes, as does an executed shell function.

     If a command consists entirely of variable assignments then the exit status of the command is that of the last command substitution if any, otherwise 0.

   Complex Commands
     Complex commands are combinations of simple commands with control operators or reserved words, together creating a larger complex command.  More generally, a command is one of the following:

     •   simple command

     •   pipeline

     •   list or compound-list

     •   compound command

     •   function definition

     Unless otherwise stated, the exit status of a command is that of the last simple command executed by the command.

   Pipelines
     A pipeline is a sequence of one or more commands separated by the control operator |.  The standard output of all but the last command is connected to the standard input of the next command.  The stan‐
     dard output of the last command is inherited from the shell, as usual.

     The format for a pipeline is:

           [!] command1 [| command2 ...]

     The standard output of command1 is connected to the standard input of command2.  The standard input, standard output, or both of a command is considered to be assigned by the pipeline before any redi‐
     rection specified by redirection operators that are part of the command.

     If the pipeline is not in the background (discussed later), the shell waits for all commands to complete.

     If the reserved word ! does not precede the pipeline, the exit status is the exit status of the last command specified in the pipeline.  Otherwise, the exit status is the logical NOT of the exit status
     of the last command.  That is, if the last command returns zero, the exit status is 1; if the last command returns greater than zero, the exit status is zero.

     Because pipeline assignment of standard input or standard output or both takes place before redirection, it can be modified by redirection.  For example:

           $ command1 2>&1 | command2

     sends both the standard output and standard error of command1 to the standard input of command2.

     A ; or ⟨newline⟩ terminator causes the preceding AND-OR-list (described next) to be executed sequentially; a & causes asynchronous execution of the preceding AND-OR-list.

     Note that unlike some other shells, each process in the pipeline is a child of the invoking shell (unless it is a shell builtin, in which case it executes in the current shell – but any effect it has
     on the environment is wiped).

   Background Commands – &
     If a command is terminated by the control operator ampersand (&), the shell executes the command asynchronously – that is, the shell does not wait for the command to finish before executing the next
     command.

     The format for running a command in background is:

           command1 & [command2 & ...]

     If the shell is not interactive, the standard input of an asynchronous command is set to /dev/null.

   Lists – Generally Speaking
     A list is a sequence of zero or more commands separated by newlines, semicolons, or ampersands, and optionally terminated by one of these three characters.  The commands in a list are executed in the
     order they are written.  If command is followed by an ampersand, the shell starts the command and immediately proceeds onto the next command; otherwise it waits for the command to terminate before pro‐
     ceeding to the next one.

   Short-Circuit List Operators
     “&&” and “||” are AND-OR list operators.  “&&” executes the first command, and then executes the second command if and only if the exit status of the first command is zero.  “||” is similar, but exe‐
     cutes the second command if and only if the exit status of the first command is nonzero.  “&&” and “||” both have the same priority.

   Flow-Control Constructs – if, while, for, case
     The syntax of the if command is

           if list
           then list
           [ elif list
           then    list ] ...
           [ else list ]
           fi

     The syntax of the while command is

           while list
           do   list
           done

     The two lists are executed repeatedly while the exit status of the first list is zero.  The until command is similar, but has the word until in place of while, which causes it to repeat until the exit
     status of the first list is zero.

     The syntax of the for command is

           for variable [ in [ word ... ] ]
           do   list
           done

     The words following in are expanded, and then the list is executed repeatedly with the variable set to each word in turn.  Omitting in word ... is equivalent to in "$@".

     The syntax of the break and continue command is

           break [ num ]
           continue [ num ]

     Break terminates the num innermost for or while loops.  Continue continues with the next iteration of the innermost loop.  These are implemented as builtin commands.

     The syntax of the case command is

           case word in
           [(]pattern) list ;;
           ...
           esac

     The pattern can actually be one or more patterns (see Shell Patterns described later), separated by “|” characters.  The “(” character before the pattern is optional.

   Grouping Commands Together
     Commands may be grouped by writing either

           (list)

     or

           { list; }

     The first of these executes the commands in a subshell.  Builtin commands grouped into a (list) will not affect the current shell.  The second form does not fork another shell so is slightly more effi‐
     cient.  Grouping commands together this way allows you to redirect their output as though they were one program:

           { printf " hello " ; printf " world\n" ; } > greeting

     Note that “}” must follow a control operator (here, “;”) so that it is recognized as a reserved word and not as another command argument.

   Functions
     The syntax of a function definition is

           name () command

     A function definition is an executable statement; when executed it installs a function named name and returns an exit status of zero.  The command is normally a list enclosed between “{” and “}”.

     Variables may be declared to be local to a function by using a local command.  This should appear as the first statement of a function, and the syntax is

           local [variable | -] ...

     Local is implemented as a builtin command.

     When a variable is made local, it inherits the initial value and exported and readonly flags from the variable with the same name in the surrounding scope, if there is one.  Otherwise, the variable is
     initially unset.  The shell uses dynamic scoping, so that if you make the variable x local to function f, which then calls function g, references to the variable x made inside g will refer to the vari‐
     able x declared inside f, not to the global variable named x.

     The only special parameter that can be made local is “-”.  Making “-” local any shell options that are changed via the set command inside the function to be restored to their original values when the
     function returns.

     The syntax of the return command is

           return [exitstatus]

     It terminates the currently executing function.  Return is implemented as a builtin command.

   Variables and Parameters
     The shell maintains a set of parameters.  A parameter denoted by a name is called a variable.  When starting up, the shell turns all the environment variables into shell variables.  New variables can
     be set using the form

           name=value

     Variables set by the user must have a name consisting solely of alphabetics, numerics, and underscores - the first of which must not be numeric.  A parameter can also be denoted by a number or a spe‐
     cial character as explained below.

   Positional Parameters
     A positional parameter is a parameter denoted by a number (n > 0).  The shell sets these initially to the values of its command line arguments that follow the name of the shell script.  The set builtin
     can also be used to set or reset them.

   Special Parameters
     A special parameter is a parameter denoted by one of the following special characters.  The value of the parameter is listed next to its character.

     *            Expands to the positional parameters, starting from one.  When the expansion occurs within a double-quoted string it expands to a single field with the value of each parameter separated by
                  the first character of the IFS variable, or by a ⟨space⟩ if IFS is unset.

     @            Expands to the positional parameters, starting from one.  When the expansion occurs within double-quotes, each positional parameter expands as a separate argument.  If there are no posi‐
                  tional parameters, the expansion of @ generates zero arguments, even when @ is double-quoted.  What this basically means, for example, is if $1 is “abc” and $2 is “def ghi”, then "$@" ex‐
                  pands to the two arguments:

                        "abc" "def ghi"

     #            Expands to the number of positional parameters.

     ?            Expands to the exit status of the most recent pipeline.

     - (Hyphen.)  Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by the set builtin command, or implicitly by the shell.

     $            Expands to the process ID of the invoked shell.  A subshell retains the same value of $ as its parent.

     !            Expands to the process ID of the most recent background command executed from the current shell.  For a pipeline, the process ID is that of the last command in the pipeline.

     0 (Zero.)    Expands to the name of the shell or shell script.

   Word Expansions
     This clause describes the various expansions that are performed on words.  Not all expansions are performed on every word, as explained later.

     Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word expand to a single field.  It is only field splitting or path‐
     name expansion that can create multiple fields from a single word.  The single exception to this rule is the expansion of the special parameter @ within double-quotes, as was described above.

     The order of word expansion is:

     1.   Tilde Expansion, Parameter Expansion, Command Substitution, Arithmetic Expansion (these all occur at the same time).

     2.   Field Splitting is performed on fields generated by step (1) unless the IFS variable is null.

     3.   Pathname Expansion (unless set -f is in effect).

     4.   Quote Removal.

     The $ character is used to introduce parameter expansion, command substitution, or arithmetic evaluation.

   Tilde Expansion (substituting a user's home directory)
     A word beginning with an unquoted tilde character (~) is subjected to tilde expansion.  All the characters up to a slash (/) or the end of the word are treated as a username and are replaced with the
     user's home directory.  If the username is missing (as in ~/foobar), the tilde is replaced with the value of the HOME variable (the current user's home directory).

   Parameter Expansion
     The format for parameter expansion is as follows:

           ${expression}

     where expression consists of all characters until the matching “}”.  Any “}” escaped by a backslash or within a quoted string, and characters in embedded arithmetic expansions, command substitutions,
     and variable expansions, are not examined in determining the matching “}”.

     The simplest form for parameter expansion is:

           ${parameter}

     The value, if any, of parameter is substituted.

     The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or when parameter is followed by a character that could be inter‐
     preted as part of the name.  If a parameter expansion occurs inside double-quotes:

     1.   Pathname expansion is not performed on the results of the expansion.

     2.   Field splitting is not performed on the results of the expansion, with the exception of @.

     In addition, a parameter expansion can be modified by using one of the following formats.

     ${parameter:-word}    Use Default Values.  If parameter is unset or null, the expansion of word is substituted; otherwise, the value of parameter is substituted.

     ${parameter:=word}    Assign Default Values.  If parameter is unset or null, the expansion of word is assigned to parameter.  In all cases, the final value of parameter is substituted.  Only variables,
                           not positional parameters or special parameters, can be assigned in this way.

     ${parameter:?[word]}  Indicate Error if Null or Unset.  If parameter is unset or null, the expansion of word (or a message indicating it is unset if word is omitted) is written to standard error and
                           the shell exits with a nonzero exit status.  Otherwise, the value of parameter is substituted.  An interactive shell need not exit.

     ${parameter:+word}    Use Alternative Value.  If parameter is unset or null, null is substituted; otherwise, the expansion of word is substituted.

     In the parameter expansions shown previously, use of the colon in the format results in a test for a parameter that is unset or null; omission of the colon results in a test for a parameter that is
     only unset.

     ${#parameter}         String Length.  The length in characters of the value of parameter.

     The following four varieties of parameter expansion provide for substring processing.  In each case, pattern matching notation (see Shell Patterns), rather than regular expression notation, is used to
     evaluate the patterns.  If parameter is * or @, the result of the expansion is unspecified.  Enclosing the full parameter expansion string in double-quotes does not cause the following four varieties
     of pattern characters to be quoted, whereas quoting characters within the braces has this effect.

     ${parameter%word}     Remove Smallest Suffix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in parameter, with the smallest portion of the suffix matched by
                           the pattern deleted.

     ${parameter%%word}    Remove Largest Suffix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in parameter, with the largest portion of the suffix matched by
                           the pattern deleted.

     ${parameter#word}     Remove Smallest Prefix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in parameter, with the smallest portion of the prefix matched by
                           the pattern deleted.

     ${parameter##word}    Remove Largest Prefix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in parameter, with the largest portion of the prefix matched by
                           the pattern deleted.

   Command Substitution
     Command substitution allows the output of a command to be substituted in place of the command name itself.  Command substitution occurs when the command is enclosed as follows:

           $(command)

     or (“backquoted” version):

           `command`

     The shell expands the command substitution by executing command in a subshell environment and replacing the command substitution with the standard output of the command, removing sequences of one or
     more ⟨newline⟩s at the end of the substitution.  (Embedded ⟨newline⟩s before the end of the output are not removed; however, during field splitting, they may be translated into ⟨space⟩s, depending on
     the value of IFS and quoting that is in effect.)

   Arithmetic Expansion
     Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value.  The format for arithmetic expansion is as follows:

           $((expression))

     The expression is treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially.  The shell expands all tokens in the expression for parameter expan‐
     sion, command substitution, and quote removal.

     Next, the shell treats this as an arithmetic expression and substitutes the value of the expression.

   White Space Splitting (Field Splitting)
     After parameter expansion, command substitution, and arithmetic expansion the shell scans the results of expansions and substitutions that did not occur in double-quotes for field splitting and multi‐
     ple fields can result.

     The shell treats each character of the IFS as a delimiter and uses the delimiters to split the results of parameter expansion and command substitution into fields.

   Pathname Expansion (File Name Generation)
     Unless the -f flag is set, file name generation is performed after word splitting is complete.  Each word is viewed as a series of patterns, separated by slashes.  The process of expansion replaces the
     word with the names of all existing files whose names can be formed by replacing each pattern with a string that matches the specified pattern.  There are two restrictions on this: first, a pattern
     cannot match a string containing a slash, and second, a pattern cannot match a string starting with a period unless the first character of the pattern is a period.  The next section describes the pat‐
     terns used for both Pathname Expansion and the case command.

   Shell Patterns
     A pattern consists of normal characters, which match themselves, and meta-characters.  The meta-characters are “!”, “*”, “?”, and “[”.  These characters lose their special meanings if they are quoted.
     When command or variable substitution is performed and the dollar sign or back quotes are not double quoted, the value of the variable or the output of the command is scanned for these characters and
     they are turned into meta-characters.

     An asterisk (“*”) matches any string of characters.  A question mark matches any single character.  A left bracket (“[”) introduces a character class.  The end of the character class is indicated by a
     (“]”); if the “]” is missing then the “[” matches a “[” rather than introducing a character class.  A character class matches any of the characters between the square brackets.  A range of characters
     may be specified using a minus sign.  The character class may be complemented by making an exclamation point the first character of the character class.

     To include a “]” in a character class, make it the first character listed (after the “!”, if any).  To include a minus sign, make it the first or last character listed.
